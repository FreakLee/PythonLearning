# Day11-NumPy（基础篇）

## 初识NumPy

### 什么是NumPy

NumPy（Numerical Python）是一个用于科学计算和数据分析的Python库，它提供了高效的多维数组（ndarray）对象和各种数学函数，使得在Python中进行数值计算变得更加快速和方便。NumPy是数据科学领域的核心库之一，许多其他数据科学工具和库都是基于NumPy构建的。

以下是NumPy库的一些主要特点和功能：

* 多维数组： NumPy的核心是多维数组对象（ndarray），它可以表示任意维度的数组，例如一维、二维、三维等。这使得NumPy非常适合处理矩阵运算和向量化操作。
* 数学函数： NumPy提供了丰富的数学、统计和线性代数函数，用于执行各种数值计算任务，如加减乘除、求和、均值、方差、矩阵乘法等。
* 广播功能： NumPy支持广播（broadcasting），允许你对不同形状的数组执行操作，而无需显式循环。
* 数组操作： NumPy提供了丰富的数组操作功能，包括切片、索引、拼接、分割等，使得数据处理更加高效。
* 随机数生成： NumPy包含了用于生成各种分布的随机数的功能，用于模拟实验和随机样本生成。
* 文件输入输出： NumPy支持将数组保存到磁盘或从磁盘加载数组数据，常见的文件格式如文本文件、二进制文件和NumPy专用的.npz文件。
* 快速和内存优化： NumPy的数组操作是高度优化的，使用C语言编写，因此在处理大量数据时效率很高。此外，NumPy的数据结构比Python的内置数据结构更紧凑，减少了内存开销。
* 集成其他库： NumPy与其他科学计算和数据分析库（如SciPy、Pandas、Matplotlib等）紧密集成，提供了全面的数据分析和可视化功能。

NumPy在数据科学、机器学习、深度学习、信号处理、图像处理等领域有广泛的应用。它的强大功能和高效性使得处理大规模数值数据和进行复杂的数学计算变得更加简单和高效。

### 为什么是NumPy

NumPy在许多情况下比纯Python代码更快，这主要是由于以下几个原因：

* 连续的内存布局：NumPy的数组对象（ndarray）在内存中是连续存储的。这种连续的内存布局使得对数组进行访问和操作的过程更加高效。相比之下，Python的列表（list）由于元素可以是任意类型且存储在不同的内存位置，导致了更多的内存访问和额外的指针操作，从而降低了性能。

* 预编译的底层代码：NumPy的底层实现是用C语言编写的，其中许多关键函数和算法是经过高度优化和预编译的。这些底层函数使用了高效的算法和数据结构，以最大程度地提升执行速度。相比之下，纯Python代码是解释执行的，没有经过底层优化，因此执行速度较慢。

* 向量化操作：NumPy鼓励使用向量化操作，即对整个数组或数组的一部分进行操作，而不是使用显式的循环。向量化操作利用了底层的优化代码，可以高效地在数组上执行数值计算。相比之下，使用纯Python的循环操作会引入额外的开销，导致执行速度较慢。

* 广播功能：NumPy的广播功能允许对不同形状和维度的数组进行元素级别的操作，而无需显式地进行形状转换。这种功能避免了额外的内存复制和循环操作，从而提高了执行速度。

* 整合底层库：NumPy可以与现有的使用C、C++或Fortran编写的高性能计算库进行整合。这使得底层的计算可以在高效的C代码中执行，而不需要通过Python解释器进行循环。这种整合能力可以显著提升计算密集型任务的性能。

总体而言，NumPy通过利用连续的内存布局、预编译的底层代码、向量化操作和广播功能等优势，提供了高效的数值计算能力。它在执行速度和内存效率方面优于纯Python代码，使得处理大规模数据和复杂数学运算变得更加快速和高效。

### 安装NumPy

可以利用pip工具安装NumPy，在电脑终端输入如下命令：
``` sh
pip install numpy
```
安装完毕会有如下类似信息输出：
``` 
Collecting numpy
  Downloading numpy-1.25.2-cp311-cp311-macosx_10_9_x86_64.whl (20.8 MB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 20.8/20.8 MB 1.5 MB/s eta 0:00:00
Installing collected packages: numpy
Successfully installed numpy-1.25.2
```
## 基础语法

### 数据类型
NumPy提供了丰富的数据类型用于表示数组中的元素。以下是一些常见的NumPy数据类型：

* bool：布尔类型，用于表示True或False。

* int8、int16、int32、int64：有符号整数类型，分别表示8位、16位、32位和64位整数。

* uint8、uint16、uint32、uint64：无符号整数类型，分别表示8位、16位、32位和64位无符号整数。

* float16、float32、float64：浮点数类型，分别表示16位、32位和64位浮点数。

* complex64、complex128：复数类型，分别表示由32位和64位浮点数组成的复数。

* string_、unicode_：字符串类型，分别表示字节串和Unicode串。

### NumPy数组
NumPy的主要对象是处理多维数组。以下是一些重要的概念：

* 数组（Array）：NumPy的核心数据结构是数组（ndarray），它是一个多维的、固定大小的容器，可以存储相同类型的元素。数组可以是一维、二维或更高维。

* 维度（Dimension）：数组的维度表示数组的轴的数量，也称为数组的秩（Rank）。一维数组具有一个维度，二维数组具有两个维度，依此类推。

* 形状（Shape）：数组的形状表示每个维度中的元素数量。例如，一个形状为(3, 4)的数组表示有3行和4列。

* 大小（Size）： 数组元素的总数。这等于 shape 的元素的乘积。

* 元素（Element）：数组中的单个数据项称为元素。每个元素在数组中都有一个唯一的索引，用于访问和操作它。

* 数据类型（Data Type）：数组中的元素具有特定的数据类型，如整数、浮点数、布尔值等。NumPy提供了丰富的数据类型，例如int、float、bool、string等。

* 广播（Broadcasting）：广播是一种机制，它允许不同形状的数组进行元素级操作。在广播中，NumPy会自动调整数组的形状，使得它们具有一致的形状，以便进行操作。

* 切片（Slicing）：切片是一种通过指定索引范围来获取数组的子集的方式。NumPy的切片操作类似于Python中的列表切片，允许按照维度对数组进行切片和访问。

* 聚合函数（Aggregation Function）：NumPy提供了许多聚合函数，用于计算数组的统计信息，如求和、均值、最大值、最小值等。这些函数可以在整个数组或特定轴上进行计算。

* 矩阵运算（Matrix Operation）：NumPy支持矩阵运算，如矩阵乘法、逆矩阵、转置等。这些运算可以对二维数组进行操作。

* 广义函数（Universal Functions）：广义函数是一种对数组进行元素级操作的函数，可以对数组中的每个元素进行同一种数学运算，如平方根、指数函数、对数函数等。

这些概念是NumPy中数组操作和计算的基础，了解它们对于有效地使用NumPy进行数据处理和数值计算非常重要。

### ndarray和list比较
NumPy中的数组（ndarray）和Python中的数组（list）的一些区别和联系：
区别：

* 数据类型：NumPy数组是一种固定类型的多维数组，其中所有元素的数据类型必须相同。而Python中的数组是一种动态类型的可变长度列表，可以包含不同类型的元素。

* 内存效率：NumPy数组在内存中存储的是连续的块，这使得它们在访问和操作时更高效，尤其是对于大型数据集。而Python中的数组由指针和对象组成，每个对象都有自己的标识和类型信息，因此相对而言更占用内存且访问速度较慢。

* 数学操作：NumPy数组支持向量化操作和广播，可以进行高效的数学和科学计算，如矩阵运算、数组操作、广播等。Python中的数组则需要使用循环来进行元素级操作，效率较低。

联系：

* 数组操作：无论是NumPy数组还是Python数组，都可以进行索引、切片、迭代等基本的数组操作。

* 互相转换：NumPy提供了将NumPy数组与Python列表进行转换的函数，如np.array()可以将Python列表转换为NumPy数组，而tolist()方法可以将NumPy数组转换为Python列表。

* 共同的应用场景：NumPy数组和Python数组都可以用于存储和处理数据。Python数组在一些简单的数据操作和程序逻辑中更加灵活，而NumPy数组在数值计算和科学计算领域更为常用，因为它们提供了更高效的操作和更丰富的数学函数库。

总的来说，NumPy数组和Python数组在功能和性能上有所不同，NumPy数组更适合于数值计算和科学计算的场景，而Python数组则更适合于一般的数据处理和编程任务。

### 创建NumPy数组
创建数组有5种常规机制：
* 从其他Python结构（例如，列表，元组）转换
* numpy原生数组的创建（例如，arange、ones、zeros等）
* 从磁盘读取数组，无论是标准格式还是自定义格式
* 通过使用字符串或缓冲区从原始字节创建数组
* 使用特殊库函数（例如，random）

``` py
import numpy as np

# 创建一维数组
arr1 = np.array([1, 2, 3, 4, 5])

# 创建二维数组
arr2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2_2d = np.arange(12).reshape(4,3)  #将0-11这12个数以4行三列的方式创建二维数组，打印效果如下：
"""
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
"""

# 创建三维数组
arr3_3d = np.arange(24).reshape(2,3,4)  #将0-23这24个数以shape(2,3,4)的形式创建三维数组。打印效果如下：
"""
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
"""

# 创建全零数组
zeros_arr = np.zeros((3, 4))

# 创建全一数组
ones_arr = np.ones((2, 3))

# 创建指定范围的数组
range_arr = np.arange(0, 10, 2)  # 从0到10，步长为2

# 创建随机数组
random_arr = np.random.rand(3, 2)  # 3行2列的随机数组

# 创建时显示指定数组的类型
com_arr = np.array([[1,2],[3,4]], dtype=complex)  # 2行2列的复数数组
```

### 数组操作
一维的数组可以进行索引、切片和迭代操作的，就像列表和其他Python序列类型一样。
``` py
arr = np.array([1, 2, 3, 4, 5])
arr_other = np.array([2, 3, 4, 5, 6])
arr_2d = np.arange(16).reshape(4,4)
# 访问数组元素
print(arr[0])  # 输出：1
print(arr[2:4])  # 输出：[3, 4]
# 以下两种方式等价
"""
 0  1  2  3
 4  5  6  7
 8  9 10 11
12 13 14 15
"""
# 多维数组索引
print(arr_2d[1][1]) # 输出：5
print(arr_2d[1,1])  # 输出：5

# 条件筛选
filtered_arr = arr[arr > 2]
print(filtered_arr)
# 输出：[3, 4, 5]

# 布尔索引
bool_index = np.array([True, False, True, False, True])
bool_filtered_arr = arr[bool_index]
print(bool_filtered_arr)
# 输出：[1, 3, 5]

# 多维数组切片
print(arr_2d[1:2])  # 输出：[[4 5 6 7]]
print(arr_2d[0:2,1])  # 输出：[1 5]
"""
输出：
[[ 6]
 [10]]
"""
print(arr_2d[1:3,2:3]) 
"""
输出：
[[ 5  6]
 [ 9 10]]
"""
print(arr_2d[1:3,1:3]) 

# 数组运算
print(arr + 2)  # 输出：[3, 4, 5, 6, 7]
print(arr * 3)  # 输出：[3, 6, 9, 12, 15]
print(arr + arr_other)  # 输出：[3, 5, 7, 9, 11]


# ---------------插入矩阵部分操作 以作对比
# 对于大小相同的两个矩阵，我们可以使用算术运算符（+-*/）将其相加或者相乘。NumPy对这类运算采用对应位置（position-wise）操作处理
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
"""
 [1, 2]  [5, 6]    [ 6,  8]
 [3, 4]  [7, 8]    [10, 12]
"""
print(A + B)

"""
 [1, 2]  [5, 6]    [ 5, 12]
 [3, 4]  [7, 8]    [21, 32]
"""
print(A * B)

# 逆矩阵
"""
逆矩阵是一个与原矩阵相乘后得到单位矩阵的矩阵。对于一个 n×n 的方阵 A，如果存在另一个 n×n 的方阵 B，使得 A 与 B 相乘后得到单位矩阵 I（大小为 n×n），则矩阵 B 被称为 A 的逆矩阵，记作 A^(-1)。

形式化表示为：A × A^(-1) = A^(-1) × A = I

逆矩阵的存在条件是，原矩阵 A 必须是可逆的（也称为非奇异的）。如果矩阵 A 不可逆，也就是不存在与之相乘后得到单位矩阵的矩阵 B，那么我们称 A 为奇异矩阵。

逆矩阵的性质包括：

只有方阵（行数等于列数）才有可能存在逆矩阵。
逆矩阵是唯一的，如果 A 有逆矩阵，那么它的逆矩阵是唯一的。
如果 A 与 B 都是可逆矩阵，那么 A × B 也是可逆的，并且它的逆矩阵为 B^(-1) × A^(-1)。

下面输出：
[[-2.   1. ]
 [ 1.5 -0.5]]
"""
matrix = np.array([[1, 2], [3, 4]])
inverse_matrix = np.linalg.inv(matrix)
print(inverse_matrix)


# 转置
"""
[[ 0  4  8 12]
 [ 1  5  9 13]
 [ 2  6 10 14]
 [ 3  7 11 15]]
"""
print(arr_2d.T)

# 对于不同大小的矩阵，只有两个矩阵的维度同为1时（例如矩阵只有一列或一行），我们才能进行这些算术运算，在这种情况下，NumPy使用广播规则（broadcast）进行操作处理
arr_c = np.array([1, 2])
"""
 [1, 2]  [1, 2]    [2, 4]
 [3, 4]  [1, 2]    [4, 6]
"""
print(A + arr_c)

"""
 [1, 2]  [1, 2]    [1, 4]
 [3, 4]  [1, 2]    [3, 8]
"""
print(A * arr_c)


# 点积dot()
"""
 [1, 2]  [5, 6]    [19, 22]
 [3, 4]  [7, 8]    [43, 50]

 1*5 + 2*7 = 19
 3*5 + 4*7 = 43
 1*6 + 2*8 = 22
 3*6 + 4*8 = 50
"""
# 以下三种打印相同
print(np.dot(A,B))
print(A @ B)  # Python 3.5及以上版本
print(np.matmul(A, B))


# 数组形状操作
print(arr.shape)  # 输出：(5,)  
reshaped_arr = arr.reshape((5, 1))
print(reshaped_arr.shape)  # 输出：(5, 1)
"""
输出：
[[1]
 [2]
 [3]
 [4]
 [5]]
"""
print(reshaped_arr)  #注意与print(arr)的区别：[1 2 3 4 5]

orgin_arr = np.array([1, 2, 3, 4, 5,6])
print(orgin_arr.shape)  # 输出：(6,)  
"""
输出：
[[1 2 3]
 [4 5 6]]
"""
print(orgin_arr.reshape(2,3))
"""
输出：
[[1 2]
 [3 4]
 [5 6]]
"""
print(orgin_arr.reshape(3,2))


# 数组聚合操作
print(np.mean(arr)) # 输出：3.0
print(np.max(arr))  # 输出：5
print(np.sum(arr))  # 输出：15
print(np.max(arr_2d))  # 输出：15
print(np.mean(arr_2d))  # 输出：7.5

"""
 0  1  2  3
 4  5  6  7
 8  9 10 11
12 13 14 15
"""
print(np.max(arr_2d[0:3]))  # 输出：11
# 找到每行的最大值（沿列聚合）：
print(np.max(arr_2d, axis=0))  # 输出：[12 13 14 15]
# 找到每列的最小值（沿行聚合）：
print(np.min(arr_2d, axis=1))  # 输出：[ 0  4  8 12]
# 按行求和（沿列聚合）：
print(np.sum(arr_2d, axis=0))  # 输出：[24 28 32 36]
# 按列求和（沿行聚合）：
print(np.sum(arr_2d, axis=1))  # 输出：[ 6 22 38 54]


# 数组拼接
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

concatenated_arr = np.concatenate((arr1, arr2))
print(concatenated_arr)
# 输出：[1 2 3 4 5 6]

# 数组分割
arr = np.array([1, 2, 3, 4, 5, 6])
splitted_arr = np.split(arr, 3)
print(splitted_arr)
# 输出：[array([1, 2]), array([3, 4]), array([5, 6])]
```

### 广播（broadcasting）
在NumPy中，广播（broadcasting）是一种用于处理不同形状的数组之间的运算的机制。当进行二进制操作（如加法、减法、乘法等）时，如果两个数组的形状不完全相同，NumPy会尝试通过广播规则自动调整数组的形状，使它们能够进行元素级的运算，而无需显式地写循环来处理。

标量和数组的广播
``` py
import numpy as np

# 创建一个数组
arr = np.array([1, 2, 3])

# 用标量与数组相加
result = 2 + arr

print(result)
# [3 4 5]
```

数组形状不匹配的广播
``` py
import numpy as np

# 创建两个数组
arr1 = np.array([[1, 2, 3], [4, 5, 6]])
arr2 = np.array([10, 20, 30])

# 对两个数组进行加法运算
result = arr1 + arr2

print(result)
"""
[[11 22 33]
 [14 25 36]]
"""
```

无法广播的情况
``` py
import numpy as np

# 创建两个数组
arr1 = np.array([[1, 2, 3], [4, 5, 6]])
arr2 = np.array([10, 20])

# 尝试对两个数组进行加法运算
result = arr1 + arr2
```
运行这段代码会引发一个ValueError异常，提示无法广播这两个数组。这是因为在广播规则中，两个数组的任一维度要么相等，要么其中一个数组的维度为1。在这个例子中，arr2的形状为(2,)，无法与arr1的形状(2, 3)进行广播，因为它们在第二个维度的长度不相等，也没有一个维度的长度为1。

以下是广播机制的规则：

* 维数不匹配： 如果两个数组的维数不相等，NumPy会在较小的数组的前面插入一个长度为1的维度，直到两个数组的维数相同。

* 形状不匹配： 对于每个维度，数组的形状要么相等，要么其中一个数组的维度长度为1。如果在某个维度上，数组的形状既不相等也不是1，那么广播操作将会引发错误。

* 数组迭代： 当两个数组的形状不匹配时，广播会在维度上进行迭代。具体来说，对于长度不为1的维度，NumPy会将其展开，使其在迭代时具有相同长度。

* 操作符和函数： 所有的通用函数（ufuncs）都可以使用广播，包括二元操作（如加、减、乘、除等）和一元操作（如取负、开方等）。

